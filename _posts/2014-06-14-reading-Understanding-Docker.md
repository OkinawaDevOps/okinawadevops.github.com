---
layout: post
tags : [Docker]
---
{% include JB/setup %}

## [kinjo](https://github.com/kinjo)
Docker 1.0 がリリースされ、何が変わったのか知りたくて、以下なドキュメントを読む。

[http://docs.docker.com/introduction/understanding-docker/](http://docs.docker.com/introduction/understanding-docker/)

結論： Docker Engine のいくらか詳細が説明されているので、ちゃんと読んだほうがいい。

## What can I use Docker for?
Docker を何に使うか。

**アプリの高速配送**

コンテナにはローカルで開発しているアプリケーションやサービスが全て内包されており、
継続的インテグレーションや開発フローに統合できる。

開発者の誰かが、ローカルで開発中のスタックを、同僚とシェアするも容易い。
テスト環境へ持っていくのも容易いし、テスト環境から本番環境、もしくは
開発環境にプッシュするも容易くなる。

**もっと手軽にデプロイとスケーリング**

ポータブルであること。

Docker コンテナは開発者のローカルホストでも実行できるし、
データセンター、もしくはクラウド上の物理、仮想マシン上でも実行できる。

**高密度化**

ハイパバイザー型の仮想マシンの代替として、高効率での実現を提供する。
とくに高密度な環境に便利。

持っている分よりも多くのリソースを入手したい
小規模、または中規模の開発においても便利。

## What are the major Docker components?
Docker は２つのメジャーコンポーネントをもつ。

- Docker：オープンソースな仮想コンテナのプラットフォーム
- Docker Hub：Dockerコンテナのシェア・管理のためのPaaSプラットフォーム

Docker のライセンスは Apache 2.0

## What is Docker's architecture?
Docker はクライアント・サーバアーキテクチャ。

Docker クライアントが Docker デーモンと通信する。

Docker クライアントと Docker デーモンは同じシステム上で走る。
リモートの Docker デーモンに Docker クライアントを接続も可。

Docker クライアントとサービスは、ソケットまたは RESTful API を通じて通信する。

### Docker daemon
Docker デーモンはホストマシン上で走る。
ユーザは、デーモンと直接対話しない代わりに Docker クライアントを使う。

### Docker client
Docker のユーザインタフェース。

### Inside Docker
Docker 内に３つのコンポーネントがある。

- Docker images
- Docker registries
- Docker containers

#### Docker images
リードオンリーなテンプレート。
例えば、Ubuntu上にApacheとアプリがインストールされたイメージ。
イメージは Docker コンテナを作成するために使用される。
Docker は新しいイメージをビルドしたり、既存イメージをアップデートしたりする
シンプルな手法を提供し、他の人が作成したイメージをダウンロードも可。

#### Docker Registries
イメージを管理する。パブリックまたはプライベートに管理できる。
パブリックとは Docker Hub のことな模様。

#### Docker containers
Docker コンテナは Docker の実行コンポーネント。
Docker コンテナはディレクトリに近い。
Docker コンテナはアプリケーションの実行に必要な全てを含む。
各コンテナは Docker イメージから作成される。
Docker コンテナに対して、実行、起動、停止、移動、削除が可能。
各コンテナは、隔離されたセキュアなアプリケーションプラットフォームである。

## So how does Docker work?
スルー

## How does a Docker Image work?
Docker イメージはどのように動くか。

イメージはレイヤのシリーズから成っている。ユニオンファイルシステムを使い、レイヤをひとつのイメージに統合する。

ユニオンファイルシステムは、離散したファイルシステムのファイルやディレクトリを
透過的に重ねあわせ、一貫したファイルシステムを形成できるようにするもの。

これのおかげで Docker は軽量。

Docker イメージを変更するとき、例えばアプリを新しくバージョンアップするとき、
新しいレイヤーが作成される。

仮想マシンがそうしているように、イメージ全体を置き換えたり、
全体を再構成したりするよりも、
レイヤーが追加されたり更新されたりするだけである。

新しくイメージ全体を配布する必要はなく、
Docker イメージを素早くシンプルに配布し更新すればいい。

全てのイメージはベースイメージからスタートする。
自身のイメージを新しいイメージの基礎として使うこともできる。
例えばベースとなる Apache イメージがあれば、
全てのウェブアプリのベースとして使うことができる。

Docker は通常、ベースイメージを Docker Hub から取得する。
Docker イメージは、ベースイメージから、
インストラクションと呼ばれるシンプルかつ記述的なステップによりビルドされる。

インストラクションは次のようなアクションを含む。

- コマンドの実行
- ファイルやディレクトリの追加
- 環境変数の作成
- イメージからコンテナを実行する時の手順

インストラクションは Dockerfile に入れ込まれる。

イメージのビルドをリクエストしたとき Dockerfile が読み込まれ、
インストラクションが実行され、最終的なイメージが出力される。

## How does a Docker registry work?
Docker レジストリはどのように動くか。Docker レジストリは Docker イメージの保存先。

Docker イメージをビルドしたとき、 Docker Hub のパブリックレジストリ、
もしくはファイアウォールの後ろで走っている自身のレジストリにプッシュできる。

Docker クライアントで公開済みのイメージを探せるし、
コンテナをビルドするために Docker ホストに取得してこれる。

Docker Hub はイメージのためのパブリック／プライベートなストレージである。
パブリックストレージは他者から検索可能でありダウンロードされる。
プライベートストレージは検索結果からは除外され、
あなた、またはあなたのユーザからイメージ取得でき
コンテナをビルドできる。

## How does a container work?
コンテナはどのように動くか。

コンテナはOS, ユーザが追加したファイル、メタデータから成る。

各コンテナはイメージからビルドされる。

イメージは、コンテナが保持するナニ、コンテナが起動したとき走るプロセスのナニ、
その他の多様な設定データを Docker に教える。

Docker イメージはリードオンリー。Docker がイメージからコンテナを起動したとき、
イメージのトップにリードライトレイヤが追加される。

アプリはそこで走る。

## What happens when you run a container?
コンテナを走らせたとき起こること。


    docker run -i -t ubuntu /bin/bash

このコマンドを掘ってみる。

新しいコンテナを起動するための run オプションでもって
docker 実行ファイルから Docker クライアントが起動される。

コンテナを起動するため Docker クライアントが Docker デーモンに対して以下を言う。

- コンテナをビルドする Docker イメージは何か
  ここでは ubuntu 。
- コンテナが起動したとき内部で実行したいコマンド
  ここでは bin/bash

内部で何が起きるか。

- ubuntu イメージをプルする。 ubuntu イメージがローカルにあるか確認する。
  なければ Docker Hub からダウンロードする。
  イメージがあれば新しいコンテナに使用される。
- コンテナを作成する。
- ファイルシステムを確保し、リードライトレイヤをマウントする。
  コンテナがファイルシステムの中に作られ、
  イメージにリードライトレイヤが追加される。
- ネットワーク／ブリッジインタフェースが確保される。
  コンテナがローカルホストとお喋りできるよう
  ネットワークインタフェースを作成する。
- IPアドレスをセットアップする。
  プールから利用可能なIPアドレスを見つけてアタッチする。
- 指定されたプロセスを実行する。
  アプリの実行となく。
- アプリのアウトプットを取得して提供する。
  アプリがどう動いているか参照できるよう
  標準入出力、標準エラーを接続し記録する。

ここからコンテナを管理できるようになり、アプリと対話できるようになる。

ことが終われば、コンテナを停止または削除する。

## The underlying technology
基盤テクノロジ。Docker は Go で書かれていて、機能提供のため Linux カーネルの機能を使う。

**ネームスペース**

ネームスペースは隔離されたワークスペースを提供する。
これをコンテナと呼ぶ。

コンテナを走らせたとき Docker はコンテナ用にネームスペースのセットを作成する。
これは隔離されたレイヤを提供する。

コンテナは自身のネームスペースの中で走り、外にはアクセスしない。

Docker が使うネームスペースは以下、

- pid ネームスペース
  プロセスの分離に使われる
- net ネームスペース
  ネットワークインタフェースの管理に使われる
- ipc ネームスペース
  InterProcess Communication リソースへのアクセス管理に使われる
- mnt ネームスペース
  マウントポイントの管理に使われる
- uts ネームスペース
  カーネルの分離とバージョン識別に使われる。（UTS：Unix Timesharing System）

## Control groups
Docker はグループ制御に cgroups と呼ばれる技術を使う。

隔離された中でアプリを走らせるためのキーになるものは、
あなたの望むリソースを彼らだけに使わせることである。
これは、ホストにおけるコンテナが善良なマルチテナントな市民であることを保証する。

グループ制御は、Docker に、
有効なハードウェアリソースをコンテナに共有できるようにし、
もし要求されれば制限や制約を設定する。

例えば、特定のコンテナで利用可能なメモリを制限するなど。

## Union file systems
Union file systems または UnionFS は、レイヤの作成を提供する。

コンテナにビルディングブロックを提供するため、
Docker は Union file systems を使う。

Docker は Union file systems の亜種を使うことも可。
AUFS, btrfs, vfs, DeviceMapper 。

## Contaienr format
コンテナフォーマットと呼ばれるラッパーの中にこれらのコンポーネントを結びつける。

デフォルトのコンテナフォーマットは libcontainer と呼ばれる。

Docker は LXC を使う伝統的な Linux コンテナもサポートする。

Docker は将来、他のコンテナフォーマットをサポートするかも。
例えば BSD の Jails や Solaris の Zones など。
